
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Creating a CRUD API with AWS lambda and dynamoDB</title>
    <meta name="description" content="">
	
	<meta name="google-site-verification" content="mV9dWaG3eoW-q9NUnP6RKamBZn6R1_dtO0ojaj99Vb0">

    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="shortcut icon" href="../favicon.ico">

    <link rel="stylesheet" type="text/css" href="../assets/css/screen.css?v=a8cb9de651">
    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic%7COpen+Sans:700,400">

    <link rel="canonical" href="http://headly48.github.io/creating-a-crud-api-with-aws-lambda-and-dynamodb/">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <link rel="amphtml" href="http://headly48.github.io/creating-a-crud-api-with-aws-lambda-and-dynamodb/amp/">
    
    <meta property="og:site_name" content="Josh's Tech Blog">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Creating a CRUD API with AWS lambda and dynamoDB">
    <meta property="og:description" content="Intro The last few lambda functions I have created have been very basic in nature as they returned simple responses with no error handling or other integrations needed. So I thought I should try creating a slightly more complex CRUD API that links to a dynamoDB table to store a">
    <meta property="og:url" content="http://headly48.github.io/creating-a-crud-api-with-aws-lambda-and-dynamodb/">
    <meta property="article:published_time" content="2016-12-10T10:48:45.000Z">
    <meta property="article:modified_time" content="2016-12-10T10:51:08.000Z">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Creating a CRUD API with AWS lambda and dynamoDB">
    <meta name="twitter:description" content="Intro The last few lambda functions I have created have been very basic in nature as they returned simple responses with no error handling or other integrations needed. So I thought I should try creating a slightly more complex CRUD API that links to a dynamoDB table to store a">
    <meta name="twitter:url" content="http://headly48.github.io/creating-a-crud-api-with-aws-lambda-and-dynamodb/">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="Joshua Head">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Josh&#x27;s Tech Blog",
        "logo": "http://headly48.github.io/ghost/img/ghosticon.jpg"
    },
    "author": {
        "@type": "Person",
        "name": "Joshua Head",
        "url": "http://headly48.github.io/author/joshua/",
        "sameAs": [],
        "description": "Full stack developer in Melbourne Australia. Interested in learning new skills and working on new challenges"
    },
    "headline": "Creating a CRUD API with AWS lambda and dynamoDB",
    "url": "http://headly48.github.io/creating-a-crud-api-with-aws-lambda-and-dynamodb/",
    "datePublished": "2016-12-10T10:48:45.000Z",
    "dateModified": "2016-12-10T10:51:08.000Z",
    "description": "Intro The last few lambda functions I have created have been very basic in nature as they returned simple responses with no error handling or other integrations needed. So I thought I should try creating a slightly more complex CRUD API that links to a dynamoDB table to store a",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://headly48.github.io"
    }
}
    </script>

    <meta name="generator" content="Ghost 0.11">
    <link rel="alternate" type="application/rss+xml" title="Josh's Tech Blog" href="http://headly48.github.io/rss/">
</head>
<body class="post-template nav-closed">

    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="index.html#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
            <li class="nav-home" role="presentation"><a href="http://headly48.github.io/">Home</a></li>
    </ul>
        <a class="subscribe-button icon-feed" href="http://headly48.github.io/rss/">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        


<header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        
            <a class="menu-button icon-menu" href="index.html#"><span class="word">Menu</span></a>
    </nav>
</header>

<main class="content" role="main">
    <article class="post">

        <header class="post-header">
            <h1 class="post-title">Creating a CRUD API with AWS lambda and dynamoDB</h1>
            <section class="post-meta">
                <time class="post-date" datetime="2016-12-10">10 December 2016</time> 
            </section>
        </header>

        <section class="post-content">
            <h6 id="intro">Intro</h6>

<p>The last few lambda functions I have created have been very basic in nature as they returned simple responses with no error handling or other integrations needed.</p>

<p>So I thought I should try creating a slightly more complex CRUD API that links to a dynamoDB table to store a users information and skills.</p>

<p>To implement this I used the following:</p>

<ul>
<li><a href="https://serverless.com/">Serverless</a></li>
<li>DynamoDb</li>
<li>AWS Lambda</li>
<li>Node 4.3.2</li>
</ul>

<h6 id="creatingthedynamodbtable">Creating the dynamoDB table</h6>

<p>First up I needed to create a database for our api/functions to store the data in.</p>

<p>To provision the dynamoDb table I added the following into my serverless.yml file. </p>

<pre><code>resources:  
  Resources:
    usersTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: user-skills-CRUD-usersTable-${opt:stage}
        KeySchema:
          - AttributeName: userId
            KeyType: HASH
        AttributeDefinitions:
          - AttributeName: userId
            AttributeType: S
        ProvisionedThroughput:
          ReadCapacityUnits: 1
          WriteCapacityUnits: 1
    DynamoDBIamPolicy:
          Type: AWS::IAM::Policy
          DependsOn: usersTable
          Properties:
            PolicyName: lambda-dynamodb
            PolicyDocument:
              Version: '2012-10-17'
              Statement:
                - Effect: Allow
                  Action:
                    - dynamodb:GetItem
                    - dynamodb:PutItem
                    - dynamodb:ListTables
                    - dynamodb:DeleteItem
                    - dynamodb:Query
                    - dynamodb:UpdateItem
                  Resource: arn:aws:dynamodb:*:*:table/user-skills-CRUD*
            Roles:
              - Ref: IamRoleLambdaExecution
</code></pre>

<p>This will create a table with the name "user-skills-CRUD-usersTable-${opt:stage}" where the "opt:stage" variable is replaced with the stage that I am deploying too. This allowed me to have different tables for each of my different environments.</p>

<p>The DynamoDBIamPolicy section is used by serverless to create a policy with the permissions defined and assigns it to the lambda functions. Without this the functions would not be able to access the table.</p>

<p>I also define the key of the table to be the userId which is a string as it will be a GUID.</p>

<h6 id="endpoints">Endpoints</h6>

<p>Now that I have the database table setup and the permissions all ready to go it's now time to define the endpoints and the lambda functions that they will map to.</p>

<p>As part of this API I wanted to implement the following endpoints: </p>

<ul>
<li>(POST) /users - Create a user </li>
<li>(PUT) /users/{userId} - Update the users details</li>
<li>(DELETE) /users/{userId} - Delete the user</li>
<li>(GET) /users/{userId} - Read the users details </li>
</ul>

<p>To provision the endpoints in the gateway I added the following into my serverless.yml file  </p>

<pre><code>functions:  
  getUser:
    handler: index.getUser
    events:
      - http:
          path: users/{userId}
          method: get
    environment:
      usersTableName: user-skills-CRUD-usersTable-${opt:stage}
  deleteUser:
    handler: index.deleteUser
    events:
      - http:
          path: users/{userId}
          method: delete
    environment:
      usersTableName: user-skills-CRUD-usersTable-${opt:stage}
  createUser:
    handler: index.createUser
    events:
      - http:
          path: users
          method: post
    environment:
      usersTableName: user-skills-CRUD-usersTable-${opt:stage}
  updateUser:
    handler: index.updateUser
    events:
      - http:
          path: users/{userId}
          method: put
    environment:
      usersTableName: user-skills-CRUD-usersTable-${opt:stage}
</code></pre>

<p>This will create the four endpoints and also inject the table name as an environment variable into the function. Unfortunately while serverless does offer a service wide environment variable I was unable to get this to work and was forced to repeat this in each individual function which makes it slightly less clean :(</p>

<p>The variable "{userId}" in the paths will be added to the event object that is passed into the lambda function. So can be accessed like "event.pathParameters.userId"</p>

<h6 id="functions">Functions</h6>

<p>Now that everything is mapped it was time to actually start writing the code behind the functions.</p>

<p>To get started I wanted to wire up the database for local development. Locally I ran dynamoDB using docker the container can be found <a href="https://hub.docker.com/r/deangiberson/aws-dynamodb-local/">here</a> </p>

<pre><code>const AWS = require('aws-sdk');

let dynamoDb;

//Set dynamoDbEndpoint if it exists
if (process.env.dynamoDbEndpoint) {  
  console.log('*** Manually setting dynamoDb config');
  dynamoDb = new AWS.DynamoDB({accessKeyId: 'headly48', secretAccessKey: '123', region: 'us-west-2', endpoint: new AWS.Endpoint(process.env.dynamoDbEndpoint)});
} else {
  dynamoDb = new AWS.DynamoDB();
}
</code></pre>

<p>So in the index.js file I added the above code which creates a new dynamoDB with my local endpoint otherwise it defaults to using my AWS configured settings.</p>

<p>So if I want to call the createUser function against my local DB I ran the following in the command line</p>

<p><code>node -e 'process.env.dynamoDbEndpoint = "http://192.168.99.100:8000"; require("./index.js").createUser(}, null, function (blah, res) {console.log(res)})'</code></p>

<p>Now that's sorted I created a userService class which is responsible for making the calls to the database. </p>

<pre><code>class UserService {  
  constructor (dynamoDb, tableName) {

      this.dynamoDb = dynamoDb;
      this.tableName = tableName;
  }
}
</code></pre>

<p>And initialized it in the index.js by passing in the dbConnection and tableName  </p>

<pre><code>let userService = new UserService(dynamoDb, process.env.usersTableName);  
</code></pre>

<p><br></p>

<p>Now I just needed to create the createUser function in my index.js.</p>

<p>This function first validates the users email is present and then makes a call to the userService which returns a promise. If the user has been successfully saved then it will return the userId in the body with a httpStatus of 201 else returns a 500.</p>

<pre><code>module.exports.createUser = (event, context, callback) =&gt; {

  let requestBody = JSON.parse(event.body);

  if(!requestBody.email) {
    return callback(null, {statusCode: 400, body: JSON.stringify({error: 'Please provide users email'})});
  }

  userService.createUser(requestBody).then(function (user) {

    callback(null, {statusCode: 201, body: JSON.stringify(user)});
  }).catch(function (error) {
    console.log('Error creating user. ' + error);
    callback(error);
  });
};
</code></pre>

<p>Below is the createUser function in the userService. It generates a userId and creates the param to pass to dynamoDb and returns a promise.</p>

<pre><code>  createUser(userDetails) {

    let userId = uuidGenerator.v4();

    var params = {
        TableName: this.tableName,
        Item: {
          userId: { S: userId},
          email: {S: userDetails.email}
        }
    };

    if (userDetails.skills) {
      params.Item.skills = {SS: userDetails.skills}
    }

    return this.dynamoDb.putItem(params).promise().then(function (data) {
      console.log('Created user ' + userId);

      return {userId: userId};
    });
  }
</code></pre>

<p>Next the getUser function in the index.js.</p>

<pre><code>module.exports.getUser = (event, context, callback) =&gt; {

  if (!event.pathParameters.userId || !uuidvalidator(event.pathParameters.userId)) {

    return callback(null, {statusCode: 400, body: JSON.stringify({error: 'UserId is invalid'})});
  }

  userService.getUser(event.pathParameters.userId).then(function (data) {

    if (!data || Object.keys(data).length === 0) {

      callback(null, {statusCode: 404, body: {message: 'User does not exist'}});
    } else {

      callback(null, {statusCode: 200, body: JSON.stringify(data)});
    }
  }).catch(function (error) {

    callback(JSON.stringify({error: error}));
  });
};
</code></pre>

<p>And the userService function it calls</p>

<pre><code>  getUser (userId) {

    var params = {
        TableName: this.tableName,
        Key: { // a map of attribute name to AttributeValue for all primary key attributes
            userId: { S: userId}
        },
        AttributesToGet: [
            'userId',
            'email',
            'skills'
        ]
    };
    return this.dynamoDb.getItem(params).promise().then(function (data) {
      let user = {};
      user.userId = data.Item.userId.S;
      user.skills = data.Item.skills.SS;

      return user;
    });
  }
</code></pre>

<p>Next the updateUser function in the index.js</p>

<pre><code>module.exports.updateUser = (event, context, callback) =&gt; {

  if (!event.pathParameters.userId || !uuidvalidator(event.pathParameters.userId)) {

    return callback(null, {statusCode: 400, body: JSON.stringify({error: 'UserId is invalid'})});
  }

  let requestBody = JSON.parse(event.body);

  if(!requestBody.email) {
    return callback(null, {statusCode: 400, body: JSON.stringify({error: 'Please provide users email'})});
  }

  userService.updateUser(event.pathParameters.userId, requestBody).then(function () {

    callback(null, {statusCode: 204});
  }).catch(function (error) {
    console.log('Error creating user. ' + error);
    callback(error);
  });
};
</code></pre>

<p>And the function in the userService</p>

<pre><code>  updateUser (userId, userDetails) {

    var params = {
        TableName: this.tableName,
        Key: { // a map of attribute name to AttributeValue for all primary key attributes
          userId: { S: userId}
        },
        AttributeUpdates: {}
    };

    if (userDetails.email) {
      params.AttributeUpdates.email = {
        Action: 'PUT',
        Value: {S: userDetails.email}
      }
    }

    if (userDetails.skills) {
      params.AttributeUpdates.skills = {
        Action: 'PUT',
        Value: {SS: userDetails.skills}
      }
    }

    return this.dynamoDb.updateItem(params).promise();
  }
</code></pre>

<p>Finally is the deleteUser function</p>

<pre><code>module.exports.deleteUser = (event, context, callback) =&gt; {

  let requestBody = JSON.parse(event.body);

  if (!event.pathParameters.userId || !uuidvalidator(event.pathParameters.userId)) {

    return callback(null, {statusCode: 400, body: JSON.stringify({error: 'UserId is invalid'})});
  }

  userService.deleteUser(event.pathParameters.userId).then(function () {

    callback(null, {statusCode: 204});
  }).catch(function (error) {
    console.log('Error creating user. ' + error);
    callback(error);
  });
};
</code></pre>

<p>And the function in the userService  </p>

<pre><code>  deleteUser(userId) {

    var params = {
        TableName: this.tableName,
        Key: {
          userId: { S: userId}
        }
    };

    return this.dynamoDb.deleteItem(params).promise();
  }
</code></pre>

<h6 id="deploying">Deploying</h6>

<p>Now for the fun part :D. <br>
Deploying to AWS which is as simple as running the command <code>serverless deploy --stage dev</code>. </p>

<p><img src="../content/images/2016/12/Deploy.JPG" alt=""></p>

<p>As I have used the stage var in the serverless.yml file I now have to include the stage manually which is a little annoying and it would be nice if serverless picked up the default opts.</p>

<h6 id="summary">Summary</h6>

<p>It seemed fairly straightforward to get everything connected and working. It did take some time to workout the permissions that needed to be set and also setting environment variables/tableName was very fiddly and so ended up keeping it simple rather then constantly redeploying to see if changes to the service wide env variables fixed the issue of not being picked up correctly.</p>

<p>The postman collection to test the endpoints can be found <a href="https://www.getpostman.com/collections/34d0ceaf9a0b6d66922b">here</a> <br>
To see the full code and more commands to run locally checkout my <a href="https://github.com/headly48/blog-samples/tree/master/user-skills-CRUD">Github</a></p>
        </section>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            var disqus_shortname = 'https-headly48-github-io'; // required: replace example with your forum shortname
            var disqus_identifier = '';
         
            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>



        <footer class="post-footer">



            <section class="author">
                <h4><a href="../author/joshua/">Joshua Head</a></h4>

                    <p>Full stack developer in Melbourne Australia. Interested in learning new skills and working on new challenges</p>
                <div class="author-meta">
                    
                    
                </div>
            </section>


            <section class="share">
                <h4>Share this post</h4>
                <a class="icon-twitter" href="https://twitter.com/intent/tweet?text=Creating%20a%20CRUD%20API%20with%20AWS%20lambda%20and%20dynamoDB&amp;url=http://headly48.github.io/creating-a-crud-api-with-aws-lambda-and-dynamodb/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <span class="hidden">Twitter</span>
                </a>
                <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://headly48.github.io/creating-a-crud-api-with-aws-lambda-and-dynamodb/" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <span class="hidden">Facebook</span>
                </a>
                <a class="icon-google-plus" href="https://plus.google.com/share?url=http://headly48.github.io/creating-a-crud-api-with-aws-lambda-and-dynamodb/" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <span class="hidden">Google+</span>
                </a>
            </section>


        </footer>

    </article>

</main>

<aside class="read-next">
    <a class="read-next-story prev no-cover" href="../severless-making-lambda-deployments-easy/">
        <section class="post">
            <h2>Serverless - Making lambda deployments easy</h2>
            <p>In my last post I worked on my first lambda function and went through the process of manually setting…</p>
        </section>
    </a>
</aside>



        <footer class="site-footer clearfix">
            <section class="copyright"><a href="http://headly48.github.io">Josh's Tech Blog</a> © 2016</section>
            <section class="poweredby">Proudly published with <a href="https://ghost.org">Ghost</a></section>
        </footer>

    </div>

    <script type="text/javascript" src="https://code.jquery.com/jquery-1.12.0.min.js"></script>
    
    <script type="text/javascript" src="../assets/js/jquery.fitvids.js?v=a8cb9de651"></script>
    <script type="text/javascript" src="../assets/js/index.js?v=a8cb9de651"></script>

</body>
